# cmaj = scale(C2,MAJOR,num_octaves= 5) # list of 36 notes
# dmaj = scale(D2,MAJOR,num_octaves= 5)
# emin = scale(E2,MINOR,num_octaves= 5)
# fmaj = scale(F2,MAJOR,num_octaves= 5)
# fmin = scale(F2,MINOR,num_octaves= 5)
# gmaj = scale(G2,MAJOR,num_octaves= 5)
# amin = scale(A2,MINOR,num_octaves= 5)
# bmaj = scale(B2,MAJOR,num_octaves= 5)

# revtrag = [cmaj, amin, emin, gmaj]
# lotr = [emin, cmaj, gmaj, dmaj]
# glass = [emin, cmaj, gmaj, bmaj]
# wagon = [gmaj, dmaj, emin, cmaj]
# purty = [cmaj, emin, fmaj, fmin]

# arp = [0,2,4,7,9,11,14,16,18,21,23,25,28,30,32,35] # note values for arpeggiation, 0-indexed

# def my_loop():
#   use_synth(BLADE)
#   with Fx(ECHO):



# iter = 1
# frame = 0

# with_fx :echo do
#   live_loop :test do
#     mynote = arp[iter % 16] # iterate over the sequence â€“ this is where your normalized data go
#     myrand = arp[rand_i(16)] # random value from the arp
    
#     if ((iter % 16) == 0)  # at the end of the sequence
#       frame = frame+1
#     end
    
#     if one_in(2)
#       play (wagon[(frame % 4)])[mynote]
#     else
#       play (wagon[(frame % 4)])[myrand]
#     end
    
#     iter = iter+1
#     sleep 0.2
#   end
# end